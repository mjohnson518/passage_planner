---
alwaysApply: true
---

# Passage Planner Development Rules

## Core Development Principles

- Always prioritize code quality, readability, and maintainability over clever or overly concise solutions
- Follow language-specific best practices and common conventions for each technology
- Prioritize type safety and explicit typing where applicable
- Implement proper error handling with informative error messages
- Write self-documenting code with clear variable/function names that explain their purpose
- Include comments only for complex logic or non-obvious decisions, not for obvious operations
- Optimize for performance only when necessary; prioritize clarity first
- Consider security implications in all code you produce
- **Security and accuracy take absolute precedence over speed or convenience**

## Maritime Safety Platform Principles

**CRITICAL CONTEXT: You are building life-safety infrastructure for mariners.**

Every line of code in Helmwise has the potential to impact the safety of sailors at sea. This is not just a web application—it is a decision support system that people will rely on for safe passage planning in potentially hazardous conditions.

### Safety-First Development Mindset

**Always Remember:**
- Incorrect weather forecasts can lead to dangerous situations at sea
- Route calculation errors could direct vessels into hazards
- Tidal miscalculations can cause groundings
- Safety warnings must be accurate, timely, and actionable
- System failures at sea could leave mariners without critical information

**Safety-Critical Code Areas (EXTRA SCRUTINY REQUIRED):**
- `agents/safety/src/` - Safety decision logic and warning generation
- `agents/weather/src/` - Weather interpretation and forecasting
- `agents/route/src/` - Navigation routing and waypoint calculations
- `agents/tidal/src/` - Tidal predictions and current analysis
- Any code that influences navigation decisions
- Any code that generates safety recommendations
- All alert and notification systems

**For Safety-Critical Code:**
- Require ≥90% test coverage (no exceptions)
- Implement multiple validation layers
- Use conservative safety margins (err on side of caution)
- Log all decisions with full context for audit trails
- Implement multiple data sources for cross-validation where possible
- Never suppress or ignore safety-related errors
- Test extensively with edge cases and extreme conditions
- Conduct peer review for all changes
- Document all assumptions and limitations clearly

### Data Quality & Reliability

**Weather Data:**
- Always validate data freshness (reject stale data)
- Cross-validate forecasts from multiple sources
- Flag low-confidence predictions clearly
- Never interpolate or guess missing critical data
- Provide data source transparency to users

**Navigation Data:**
- Validate all coordinates and calculations
- Use high-precision arithmetic for calculations
- Account for coordinate system differences
- Validate depth and clearance data
- Cross-reference multiple chart sources

**Tidal Data:**
- Validate prediction algorithms against known benchmarks
- Include prediction confidence levels
- Account for local tidal anomalies
- Provide data source and prediction model transparency

### Conservative Safety Margins

**Always implement generous safety margins:**
- Depth calculations: minimum 20% clearance under keel
- Weather conditions: adjust thresholds based on crew experience
- Fuel reserves: minimum 20% safety margin
- Water reserves: minimum 30% safety margin
- Time estimates: include weather delay buffer (+20%)
- Bridge clearances: account for tide + vessel motion

### Fail-Safe Principles

**When in doubt, fail safely:**
- If data quality is questionable, flag it prominently
- If calculation confidence is low, recommend caution
- If forecasts disagree, present worst-case scenario
- If external services fail, never guess—inform user clearly
- Provide manual override capability, but require acknowledgment
- Log all overrides for accountability

### Transparency & User Empowerment

**Users must understand system limitations:**
- Clearly communicate data sources and ages
- Show forecast confidence levels
- Explain calculation methods and assumptions
- Provide "how we calculated this" explanations
- Never hide uncertainty or limitations
- Enable users to make informed decisions

### Audit Trail Requirements

**For maritime safety and liability:**
- Log all passage plans with full context
- Record all data sources and timestamps
- Track all user decisions and overrides
- Maintain immutable audit logs
- Include correlation IDs for request tracing
- Log system state at time of calculations
- Enable post-incident analysis

## Language-Specific Guidelines

### TypeScript/Node.js

- Use strict TypeScript configuration with no implicit any
- Prefer async/await over callbacks or raw promises
- Implement proper error handling with custom error classes
- Use TypeScript utility types (Pick, Omit, Partial, Record) appropriately
- Follow functional programming principles where applicable
- Use dependency injection for better testability
- Implement proper logging with structured log formats
- Use environment variables for all configuration
- Leverage TypeScript's type guards and narrowing
- Follow Node.js best practices for event loop management

### Next.js 14 / React

- Use App Router exclusively (not Pages Router)
- Implement Server Components by default, Client Components only when necessary
- Mark Client Components with 'use client' directive at the top of the file
- Separate server actions into dedicated files
- Follow React Server Components patterns for data fetching
- Use Suspense boundaries for loading states
- Implement proper error boundaries
- Optimize images with Next.js Image component
- Use next/font for font optimization
- Implement proper metadata for SEO
- Follow React hooks rules and best practices
- Use React.memo, useMemo, useCallback judiciously for performance
- Implement proper form handling with server actions

### Model Context Protocol (MCP)

- Design agents with single responsibility principle
- Implement proper error handling and recovery mechanisms
- Use structured logging for agent interactions
- Design idempotent operations where possible
- Implement proper timeout and retry logic
- Monitor agent health and performance metrics
- Document agent capabilities and limitations
- Use type-safe message passing between agents
- Implement graceful degradation when agents fail
- Design for horizontal scalability

### Database (PostgreSQL/Supabase)

- Use parameterized queries to prevent SQL injection
- Implement proper indexing strategy for query performance
- Use database transactions for data consistency
- Follow Row Level Security (RLS) policies in Supabase
- Implement proper connection pooling
- Use migrations for all schema changes
- Never commit migration files without review
- Document complex queries and their purpose
- Optimize queries before deploying to production
- Use database views for complex read operations

### Redis

- Use appropriate data structures for use cases
- Implement proper key naming conventions with prefixes
- Set appropriate TTLs for cached data
- Handle cache misses gracefully
- Use Redis transactions (MULTI/EXEC) when needed
- Monitor memory usage and implement eviction policies
- Use Redis for session management and rate limiting
- Document cache invalidation strategies

## Project-Specific Guidelines

### Helmwise Naming Convention

- Always refer to the product as "Helmwise" in user-facing contexts
- Use "passage_planner" for technical references and repository names
- Maintain brand consistency across all communications

### Agent Development

- All agents must implement health check endpoints
- Agents must gracefully handle service interruptions
- Implement circuit breaker pattern for external API calls
- Log all agent interactions for debugging and analytics
- Each agent must have comprehensive error handling
- Document agent decision-making processes
- Test agents in isolation before integration

### Authentication & Authorization

- Use Supabase Auth exclusively for user authentication
- Implement JWT token validation on all protected routes
- Use role-based access control (RBAC) for admin features
- Implement rate limiting on authentication endpoints
- Log all authentication attempts for security monitoring
- Handle token refresh seamlessly
- Never expose sensitive user data in logs or errors

### Subscription & Billing

- Use Stripe webhooks for subscription status updates
- Verify webhook signatures for all Stripe events
- Implement idempotent webhook handlers
- Track subscription limits and enforce them
- Handle payment failures gracefully with user notifications
- Log all billing events for audit trails
- Test billing flows in Stripe test mode before production
- Implement proper proration for plan changes

### Email Communications

- Use React Email for all email templates
- Test emails across multiple email clients
- Implement proper email deliverability practices
- Use Resend API with proper error handling
- Track email delivery status
- Implement unsubscribe functionality
- Follow CAN-SPAM compliance
- Use transactional email best practices

### Analytics & Monitoring

- Track all critical user actions and feature usage
- Implement business metrics (MRR, ARR, churn, etc.)
- Use structured logging for easy querying
- Monitor API response times and error rates
- Set up alerts for critical failures
- Track agent performance and success rates
- Implement user behavior funnels
- Monitor Core Web Vitals for frontend performance

## Project Structure & Organization

```
passage-planner/
├── frontend/              # Next.js application
│   ├── app/              # App router pages
│   ├── components/       # Reusable UI components
│   ├── contexts/         # React contexts
│   ├── hooks/            # Custom hooks
│   └── lib/              # Utilities and services
├── orchestrator/         # MCP orchestrator
│   ├── services/         # Core services
│   └── config/           # Configuration
├── agents/               # Specialized agents
├── shared/               # Shared types and utils
├── emails/               # Email templates
├── infrastructure/       # Docker/K8s configs
└── tests/                # All test suites
```

- Keep components small and focused on single responsibility
- Place reusable components in shared locations
- Use barrel exports (index.ts) for cleaner imports
- Organize by feature, not by file type
- Keep configuration in dedicated config files
- Separate business logic from UI components

## Security Considerations

### Critical Security Rules

- **Never commit sensitive information** (API keys, secrets, private keys, tokens)
- **Always validate and sanitize user inputs** on both client and server
- **Implement rate limiting** on all public endpoints
- **Use HTTPS exclusively** in production
- **Implement CSRF protection** for state-changing operations
- **Follow principle of least privilege** for all permissions
- **Encrypt sensitive data** at rest and in transit
- **Implement proper session management** with secure cookies
- **Validate JWT tokens** on every protected request
- **Use Stripe webhook signatures** to verify payment events
- **Implement SQL injection prevention** with parameterized queries
- **Sanitize logs** to prevent sensitive data exposure
- **Use Content Security Policy** headers
- **Implement proper CORS policies**
- **Regular security audits** of dependencies

### Environment Variables

- Never hardcode configuration values
- Use .env.local for local development
- Store production secrets in secure vaults (never in repository)
- Document all required environment variables in .env.example
- Use different values for development, staging, and production
- Rotate secrets regularly
- Validate required environment variables on startup

## External Service Integration Workflow

### MANDATORY Pre-Integration Protocol

**BEFORE implementing any external service integration, ALWAYS:**

1. **Create Integration Documentation**
   - Create `docs/integrations/[SERVICE_NAME]_SETUP.md`
   - Document service purpose and use case
   - Include provisioning steps with screenshots
   - Document pricing structure and quotas
   - List rate limits and throttling rules
   - Include cost estimation formulas
   - Document authentication methods

2. **PAUSE for Service Provisioning**
   - **DO NOT proceed with implementation until service is provisioned**
   - Request project owner approval for service costs
   - Wait for production API keys/credentials
   - Verify account setup and access

3. **Configuration Setup**
   - Add required environment variables to .env.example
   - Document variable format and where to obtain values
   - Set up separate keys for development/staging/production
   - Configure rate limiting parameters

4. **Only After Provisioning:**
   - Implement service integration code
   - Add error handling and retry logic
   - Implement circuit breaker pattern
   - Add monitoring and cost tracking
   - Create comprehensive tests

### External Service Requirements

**Production-Grade Integrations Only:**
- **NO mock implementations or placeholders in production code**
- **NO hardcoded sample data as fallbacks**
- All integrations must use real, production-ready APIs
- Implement proper error handling for API failures
- Use fallback strategies with real alternative services (not mocks)
- Test with actual API responses (captured for test replay)

**Required for Each Integration:**
- Retry logic with exponential backoff
- Circuit breaker pattern implementation
- Rate limit handling and throttling
- Cost tracking and quota monitoring
- Comprehensive error logging with context
- Timeout handling (default 30s, configurable)
- Health check endpoint
- Graceful degradation strategy

**Services Requiring Provisioning:**
- ECMWF API (European weather forecasting)
- UK Met Office DataPoint (North Atlantic weather)
- Windy API (high-resolution wind data)
- Noonsite API (cruising and port information)
- OpenSeaMap API (marina and anchorage data)
- AIS Data Provider (vessel tracking - MarineTraffic/VesselFinder)
- Any other third-party weather, navigation, or maritime data services

**Cost Monitoring:**
- Track API call volume per service
- Monitor quota usage vs limits
- Alert when approaching quota thresholds (80%)
- Generate monthly cost reports
- Implement cost optimization strategies

## Testing & Documentation

### Testing Requirements (MANDATORY TARGETS)

**Coverage Targets:**
- **Overall codebase: ≥85% coverage (statements, branches, functions, lines)**
- **Safety-critical code: ≥90% coverage (agents/safety, route calculations, weather interpretation)**
- **Business logic: ≥85% coverage**
- **API endpoints: ≥80% coverage**

**Required Test Types:**
- **Unit Tests:** All business logic, utility functions, calculations
- **Integration Tests:** All API endpoints, external service integrations, database operations
- **E2E Tests:** Complete user workflows (signup → passage planning → export)
- **Load Tests:** Concurrent user scenarios (10, 50, 100, 500+ users)
- **Chaos Tests:** Agent failures, network partitions, API outages, database failures
- **Performance Tests:** Automated benchmarking in CI/CD

**Safety-Critical Testing (HIGHEST PRIORITY):**
- `agents/safety/src/` - All safety decision logic with edge cases
- `agents/weather/src/` - Weather interpretation and forecasting accuracy
- `agents/route/src/` - Route calculation accuracy and optimization
- `agents/tidal/src/` - Tidal prediction and current calculations
- `orchestrator/src/Orchestrator.ts` - Agent coordination and error propagation

**Test Before Every Commit:**
- All existing tests must pass
- New code must include corresponding tests
- Coverage must not decrease
- Performance benchmarks must not regress

**External API Integration Testing:**
- Test with real API responses (capture and replay for tests)
- Test error scenarios (timeouts, rate limits, invalid responses)
- Test retry logic and exponential backoff
- Test circuit breaker behavior
- Test fallback strategies

### Documentation Standards

- Document all API endpoints with request/response examples
- Maintain up-to-date README for each major component
- Document environment variables and configuration
- Include setup instructions for local development
- Document agent capabilities and decision logic
- Create runbooks for common operational tasks
- Document deployment procedures
- Maintain changelog for significant updates

## Git Workflow & Commit Policy

### Commit Rules (CRITICAL)

- **NEVER commit or push without explicit approval from project owner**
- **Always pause at logical breakpoints and request permission to commit**
- **MANDATORY: Pause at end of each development phase for comprehensive checkpoint review**
- **All commit messages must be 4 words maximum**
- **Always request confirmation of commit message before committing**
- **Multiple related changes require multiple separate commits**
- **Each commit should represent a single logical change**

### Phase Checkpoint Protocol (MANDATORY)

After completing any major development phase, ALWAYS pause and provide:

1. **Comprehensive Phase Summary**
   - What was accomplished in this phase
   - Changes made to codebase (files created/modified)
   - Features implemented

2. **Test Coverage Report**
   - Current coverage percentages (overall and by module)
   - Coverage delta from previous checkpoint
   - Gaps identified and plan to address

3. **Performance Impact Assessment**
   - Benchmark results for new features
   - Comparison to performance targets
   - Any performance regressions identified

4. **Security Considerations Review**
   - Security implications of changes
   - New vulnerabilities introduced or mitigated
   - Authentication/authorization changes

5. **Documentation Completeness Check**
   - What documentation was created/updated
   - Any documentation gaps remaining

6. **External Service Status**
   - Status of any external API integrations
   - Current costs and quota usage
   - Rate limiting status

7. **Issues/Blockers Encountered**
   - Problems discovered during implementation
   - Technical debt introduced
   - Unresolved issues

8. **Recommendations for Next Phase**
   - Suggested priorities
   - Dependencies identified
   - Risk factors

**CRITICAL:** Request explicit approval from project owner before proceeding to next phase or committing code

### Commit Message Format

✅ Good examples:
- "Add weather agent endpoint"
- "Fix subscription billing bug"
- "Update route optimization algorithm"
- "Refactor authentication service"

❌ Bad examples:
- "Updated files and fixed some bugs"
- "Work in progress changes"
- "Misc improvements and refactoring"

### Branch Strategy

- Use feature branches for all development
- Branch naming: `feature/description`, `fix/description`, `refactor/description`
- Keep branches short-lived (merge within days, not weeks)
- Rebase feature branches before merging
- Squash commits when merging to main if appropriate
- Delete branches after merging

### Files NEVER to Commit

Never add, commit, or push the following:
- `.env` or `.env.local` files
- Any files containing API keys, tokens, or secrets
- `node_modules/` directory
- Build artifacts (`dist/`, `.next/`, etc.)
- IDE-specific files not in `.gitignore`
- Database dumps or backups
- Log files
- User-uploaded content
- SSL certificates or private keys
- Temporary or cache files
- Any files marked as sensitive in project documentation

## Code Review & Quality

### Before Requesting Commit Approval (MANDATORY CHECKLIST)

**Every single time before requesting permission to commit, verify ALL of the following:**

1. **Code Quality**
   - [ ] All linters pass (ESLint, TypeScript compiler)
   - [ ] All formatters applied (Prettier)
   - [ ] No console.log statements in production code
   - [ ] No commented-out code blocks
   - [ ] No TODO comments without tracking issues
   - [ ] Code follows project conventions and patterns

2. **Testing**
   - [ ] All existing tests pass
   - [ ] New tests written for new functionality
   - [ ] Test coverage meets targets (85% overall, 90% safety-critical)
   - [ ] Coverage did not decrease from previous commit
   - [ ] Edge cases are tested
   - [ ] Error scenarios are tested

3. **Security**
   - [ ] No hardcoded secrets, API keys, or credentials
   - [ ] All user inputs are validated and sanitized
   - [ ] Authentication/authorization properly implemented
   - [ ] No SQL injection vulnerabilities
   - [ ] Sensitive data not logged
   - [ ] Dependencies checked for vulnerabilities (npm audit)

4. **Documentation**
   - [ ] Code comments added for complex logic
   - [ ] README updated if needed
   - [ ] API documentation updated if endpoints changed
   - [ ] Environment variables documented in .env.example
   - [ ] Integration docs updated if external services added

5. **Performance**
   - [ ] No obvious performance issues introduced
   - [ ] Database queries optimized
   - [ ] Proper caching implemented where needed
   - [ ] No memory leaks introduced
   - [ ] Performance benchmarks run if relevant

6. **Safety-Critical Review (if applicable)**
   - [ ] Safety-critical code has ≥90% test coverage
   - [ ] Multiple validation layers implemented
   - [ ] Conservative safety margins applied
   - [ ] Audit logging implemented
   - [ ] Error handling fail-safe
   - [ ] Data freshness validation implemented
   - [ ] User transparency maintained

7. **Commit Hygiene**
   - [ ] Commit message is ≤4 words
   - [ ] Commit represents single logical change
   - [ ] No files on exclusion list included
   - [ ] No build artifacts or dependencies included
   - [ ] .gitignore is properly configured

**Only after ALL items are checked, request commit approval with:**
- List of files changed
- Brief description of changes
- Test coverage report
- Proposed 4-word commit message
- Any concerns or questions

### Code Review Checklist

- Does the code solve the intended problem?
- Is the code secure and free of vulnerabilities?
- Are there adequate tests?
- Is the code maintainable and readable?
- Does it follow project conventions?
- Are there any performance concerns?
- Is proper error handling implemented?
- Is documentation updated?

## Performance Optimization

### Mandatory Performance Targets

**Frontend Performance (Core Web Vitals):**
- First Contentful Paint (FCP): < 1.8s
- Largest Contentful Paint (LCP): < 2.5s
- Time to Interactive (TTI): < 3.8s
- Cumulative Layout Shift (CLS): < 0.1
- First Input Delay (FID): < 100ms

**Backend Performance:**
- API response time p50: < 100ms
- API response time p95: < 200ms
- API response time p99: < 500ms
- Agent success rate: > 99.5%
- Route calculation time (simple): < 1s
- Route calculation time (complex): < 3s
- Database query time p95: < 50ms
- Weather data accuracy: > 95%

**Scalability Targets:**
- Support 100 concurrent users without degradation
- Support 500 concurrent users with graceful degradation
- Agent queue processing lag: < 1s under normal load
- WebSocket connection capacity: 1000+ simultaneous connections

### Frontend Performance

- Implement code splitting and lazy loading
- Optimize images and use modern formats (WebP, AVIF)
- Minimize bundle size with tree shaking
- Use Server Components for static content
- Implement proper caching strategies
- Monitor Core Web Vitals
- Target metrics: FCP < 1.8s, LCP < 2.5s, TTI < 3.8s

### Backend Performance

- Implement database query optimization
- Use Redis caching effectively
- Implement connection pooling
- Monitor API response times
- Use async operations to prevent blocking
- Implement rate limiting to prevent abuse
- Profile and optimize hot code paths

## Deployment & Production

### Pre-Deployment Checklist

- All tests passing in CI/CD pipeline
- Security audit completed
- Environment variables configured
- Database migrations tested
- Monitoring and alerts configured
- Rollback plan documented
- Stakeholders notified

### Production Monitoring

- Monitor application health and uptime
- Track error rates and types
- Monitor API performance and latency
- Track business metrics (signups, conversions, churn)
- Monitor agent health and success rates
- Track infrastructure costs
- Set up alerts for critical failures

## Satoshi Standard of Excellence

The Satoshi Standard represents the highest level of technical excellence, innovation, and integrity. As an engineer adhering to this standard:

### Technical Excellence

- Write elegant, efficient, and maintainable code
- Design systems with long-term sustainability in mind
- Implement robust error handling and graceful failure modes
- Optimize for both performance and resource efficiency
- Create self-documenting code that future developers can understand

### Security-First Mindset

- Assume adversarial conditions and design defensively
- Implement defense in depth with multiple security layers
- Conduct thorough threat modeling
- Follow cryptographic best practices
- Regularly audit for vulnerabilities
- Never compromise security for convenience

### User-Centric Design

- Build systems that empower users
- Prioritize user privacy and data sovereignty
- Create accessible and inclusive interfaces
- Design for reliability and uptime
- Respect user time and attention

### Long-Term Thinking

- Design for decades, not quarters
- Consider backward compatibility
- Build systems that can evolve gracefully
- Think about resource efficiency and sustainability
- Create documentation that outlasts individual contributors

### Ethical Responsibility

- Consider societal implications of technical decisions
- Build inclusive and accessible systems
- Respect user privacy and consent
- Take responsibility for code consequences
- Avoid creating systems that could cause harm

### Continuous Improvement

- Stay current with latest developments
- Question assumptions and challenge conventions
- Learn from failures and iterate
- Maintain intellectual humility
- Mentor others and elevate the ecosystem

## Communication & Collaboration

### Working with Stakeholders

- Communicate technical decisions clearly
- Provide realistic timelines
- Flag risks and blockers early
- Seek feedback on major architectural decisions
- Document decisions and rationale

### Code Collaboration

- Review others' code constructively
- Accept feedback gracefully
- Share knowledge through documentation
- Mentor junior developers
- Contribute to team standards

## Emergency Procedures

### Incident Response

- Assess severity and impact immediately
- Notify stakeholders of critical issues
- Implement hotfix if necessary
- Document incident and resolution
- Conduct post-mortem analysis
- Update runbooks with learnings

### Rollback Procedures

- Maintain ability to rollback deployments quickly
- Test rollback procedures regularly
- Document rollback steps clearly
- Communicate rollback to stakeholders
- Analyze root cause after stabilization

## Final Notes

**Remember: You are building critical life-safety infrastructure for mariners.**

Helmwise is not just another SaaS product—it is a maritime safety platform that sailors will depend on for safe passage planning. Every feature, every calculation, every piece of data presented to users can directly impact their safety at sea.

### The Weight of Responsibility

When a sailor uses Helmwise to plan a passage:
- They trust the weather forecasts to be accurate and timely
- They rely on route calculations to avoid hazards
- They depend on tidal predictions to prevent groundings
- They trust safety warnings to alert them to dangers
- They believe the system will fail safely, not silently

A bug in a social media app causes frustration. A bug in Helmwise could contribute to a maritime incident, injury, or loss of life. This is why we hold ourselves to the highest standards.

### Priority Hierarchy (NEVER COMPROMISE)

**When trade-offs must be made, this is the order:**

1. **Safety** - Does this make the system safer or introduce risk?
2. **Accuracy** - Is the information correct and reliable?
3. **Transparency** - Do users understand limitations and confidence levels?
4. **Reliability** - Will this work consistently under all conditions?
5. **Performance** - Is it fast enough for practical use?
6. **Features** - Does this add meaningful value?
7. **Aesthetics** - Does it look good?

Never sacrifice safety for features. Never sacrifice accuracy for speed. Never hide uncertainty to make the system seem more capable than it is.

### The Satoshi Standard in Maritime Context

You are building infrastructure that must be:
- **Trustless** - Users verify our data sources, we verify our calculations
- **Decentralized** - No single point of failure that leaves sailors without information
- **Transparent** - All data sources, calculations, and confidence levels visible
- **Resilient** - Continues operating even when external services fail
- **Auditable** - Complete audit trails for accountability
- **Long-term** - Built to serve sailors for decades, not just this quarter

Like Satoshi designed Bitcoin to operate in adversarial conditions, we design Helmwise to operate in the harsh maritime environment where connectivity is poor, conditions are challenging, and the stakes are real.

### Excellence is Mandatory

This is not a "move fast and break things" project. This is a "measure twice, cut once, and verify the measurement" project.

**Every commit should reflect:**
- Careful thought about safety implications
- Thorough testing of edge cases
- Conservative safety margins
- Clear documentation of limitations
- Fail-safe error handling
- Audit trail completeness

**Before every commit, ask yourself:**
- Would I trust this code with my own safety at sea?
- Have I tested this thoroughly enough?
- Are the safety margins conservative enough?
- Is the error handling fail-safe?
- Would I be comfortable explaining this to a maritime safety board after an incident?

If the answer to any question is "no" or "I'm not sure," the code is not ready to commit.

### We Serve Sailors

At the end of the day, we serve the maritime community:
- The weekend cruiser planning their first overnight passage
- The experienced sailor crossing an ocean
- The charter captain responsible for crew and guests  
- The solo circumnavigator in remote waters
- The sailing school teaching the next generation

They all deserve a system built with integrity, care, and respect for the sea.

**When in doubt, prioritize: Safety > Accuracy > Performance > Features**

This is not just about building a product—it's about building a reliable, trustworthy system that sailors can depend on for safe passage planning. Excellence is not optional; it's mandatory. Lives may depend on it.